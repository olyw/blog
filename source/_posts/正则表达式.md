---
title: 正则表达式
date: 2023-11-11 16:02:26
tags:
---
# 1.什么是正则表达式？

正则表达式是对字符串和特殊字符操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。

正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。

# 2.元字符

###### 常用元字符

| 元字符 | 说明                         |
| :----: | :--------------------------- |
|  `.`   | 匹配除换行符以外的任意字符   |
|  `\w`  | 匹配字母或数字或下划线或汉字 |
|  `\s`  | 匹配任意的空白符             |
|  `\d`  | 匹配数字                     |
|  `\b`  | 匹配单词的开始或结束         |
|  `^`   | 匹配字符串的开始             |
|  `$`   | 匹配字符串的结束             |

###### e.g.

* `\ba\w*\b`：匹配以字母a开头的单词

    > 先是某个单词开始处`\b`，然后是字母a，然后是任意数量的字母或数字\w*,最后是单词结束处`\b`。

* `\d+`：匹配1个或更多连续的数字。

* `\b\w{6}\b`：匹配6个字符的单词。

# 3.字符转义

正则表达式中使用反斜杠`\`来转义下一个字符。在特殊字符前面加`\`，就可以使用它来做匹配字符。

# 4.重复

###### 常用的限定符

| 代码/语法 | 说明             |
| :-------: | :--------------- |
|    `*`    | 重复零次或更多次 |
|    `+`    | 重复一次或更多次 |
|   `？`    | 重复零次或一次   |
|   `{n}`   | 重复n次          |
|  `{n,}`   | 重复n次或更多次  |
|  `{n,m}`  | 重复n到m次       |

# 5.字符类

匹配没有预定义元字符的字符集合(如元音字母a,e,i,o,u)，指定一个字符指定一个字符**范围**，只需要在方括号里列出它们。

* `[aeiou]`：匹配任何一个英文元音字母,`[.?!`]：匹配标点符号.或？或！

* `\(?0\d{2}[) -]?\d{8}`：匹配几种格式的电话号码

    >首先是一个转义字符\(,它能出现0次或1次`?`,然后是一个0，后面跟着2个数字`\d{2}`，然后是)或-或空格中的一个，它出现1次或不出现`?`，最后是8个数字`\d{8}`。

# 6.分枝条件

正则表达式里的**分枝条件**指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用`|`把不同的规则分隔开。

使用分枝条件时，要注意各个条件的顺序。因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。

* `0\d{2}-\d{8}|0\d{3}-\d{7}`：匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号（如010-12345678），一种是4位区号，7位本地号（0376-2233445）。
* `\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}`：匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。
* `\d{5}-\d{4}|\d{5}：`匹配美国的邮政编码

# 7.子表达式

重复多个字符可以用小括号来指定**子表达式**（也叫**分组**），然后就可以指定这个子表达式的重复次数，或进行其他的一些操作。

* `(\d{1,3}\.){3}\d{1,3}`：匹配简单的IP地址

    >`\d{1,3}`匹配1到3位的数字，`(\d{1,3}\.){3}`匹配三位数字加上一个英文句号（这个整体也就是这个**分组**）重复三次，最后再加上一个一到三位的数字`\d{1,3}`

* `((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`：匹配正确的IP地址

# 8.反义

有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到**反义**。

###### 常用的反义代码

| 代码\语法  | 说明                                       |
| :--------: | :----------------------------------------- |
|    `\W`    | 匹配任意不是字母，数字，下划线，汉字的字符 |
|    `\S`    | 匹配任意不是空白符的字符                   |
|    `\D`    | 匹配任意非数字的字符                       |
|    `\B`    | 匹配不是单词开头或结束的位置               |
|   `[^X]`   | 匹配除了x以外的任意字符                    |
| `[^aeiou]` | 匹配除了aeiou这几个字母以外的任意字符      |

# 9.后向引用

**后向引用**用于重复搜索前面某个分组匹配的文本。

使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。

默认情况下，每个分组会自动拥有一个**组号**，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：`(?<Word>\w+)`（或者把尖括号换成'也行：`(?'Word'\w+)`）这样就把`\w+`的组名指定为Word了。要反向引用这个分组**捕获**的内容，你可以使用`\k<Word>`

* `\b(\w+)\b\s+\1\b`：匹配重复的单词

    >首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字`\b(\w+)\b`，这个单词会被捕获到编号为1的分组中，然后是一个或几个空白符`\s+`，最后是分组1中捕获的内容（也就是前面匹配的那个单词）`\1`

使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：

###### 常用分组语法

|   分类   |   代码\语法    | 说明                                                         |
| :------: | :------------: | :----------------------------------------------------------- |
|   捕获   |    `(exp)`     | 匹配exp,并捕获文本到自动命名的组里                           |
|    :     | `(?<name>exp)` | 匹配exp,并捕获文本到名称为name的组里，也可以写成`(?'name'exp)` |
|    :     |   `(?:exp)`    | 匹配exp,不捕获匹配的文本，也不给此分组分配组号               |
| 零宽断言 |   `(?=exp)`    | 匹配exp前面的位置                                            |
|    :     |   `(?<=exp)`   | 匹配exp后面的位置                                            |
|    :     |   `(?!exp)`    | 匹配后面跟的不是exp的位置                                    |
|    :     |   `(?<!exp)`   | 匹配前面不是exp的位置                                        |
|   注释   | ` (?#comment)` | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 |

# 10.零宽断言

>断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。

后行断言和先行断言有时候被称为断言，它们是特殊类型的 非捕获组（用于匹配模式，但不包括在匹配列表中）。当我们在一种特定模式之前或者之后有这种模式时，会优先使用断言。 

###### 正则表达式中使用的断言

| 符号  |     描述     |
| :---: | :----------: |
| `?=`  | 正向先行断言 |
| `?!`  | 负向先行断言 |
| `?<=` | 正向后行断言 |
| `?<!` | 负向后行断言 |

###### e.g.

* `(?<=\$)[0-9\.]*`：匹配包含 `.` 字符且前缀为 `$` 的所有数字

## 正向先行断言

正向先行断言认为第一部分的表达式的后面必须是先行断言表达式。返回的匹配结果仅包含与第一部分表达式匹配的文本。要在一个括号内定义一个正向先行断言，在括号中问号和等号是这样使用的 `(?=...)`。先行断言表达式写在括号中的等号后面。

* `(T|t)he(?=\sfat)`：匹配大写字母 T 或小写字母 t，后面跟字母 h，后跟字母 e。 在括号中，我们定义了正向先行断言，它会引导正则表达式引擎匹配后面跟着 fat 的 The 或 the。

## 负向先行断言

当我们需要指定第一部分表达式的后面不跟随某一内容时，使用负向先行断言。负向先行断言的定义跟我们定义的正向先行断言一样， 唯一的区别在于我们使用否定符号 `!` 而不是等号 `=`，例如 `(?!...)`。 

* `(T|t)he(?!\sfat)`：从输入字符串中获取全部 The 或者 the 且不匹配 fat 前面加上一个空格字符。

## 正向后行断言

正向后行断言用于获取跟随在特定模式之后的所有匹配内容。正向后行断言表示为 `(?<=...)`。

* `(?<=(T|t)he\s)(fat|mat)`：从输入字符串中获取在单词 The 或 the 之后的所有 fat 和 mat 单词。

## 负向后行断言

负向后行断言是用于获取不跟随在特定模式之后的所有匹配的内容。负向后行断言表示为 `(?<!...)`。

* `(?<!(T|t)he\s)(cat)`：在输入字符中获取所有不在 The 或 the 之后的所有单词 cat。

# 11.注释

小括号的另一种用途是通过语法`(?#comment)`来包含注释。要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在`#`后面到这一行结束的所有文本都将被当成注释忽略掉。

* `2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)`

# 12.贪婪与懒惰

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。有时，我们更需要**懒惰**匹配，也就是匹配**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号`?`。

* `a.*b`：匹配最长的以a开始，以b结束的字符串

    >如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为**贪婪**匹配。
    >
    >为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？
    >
    >因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权。

* `a.*?b`：匹配最短的，以a开始，以b结束的字符串。

    > 如果把它应用于*aabab*的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。

###### 懒惰限定符

| 代码/语法 |              说明               |
| :-------: | :-----------------------------: |
|   `*？`   |   重复任意次，但尽可能少重复    |
|   `+？`   | 重复1次或更多次，但尽可能少重复 |
|   `??`    |  重复0次或1次，但尽可能少重复   |
| `{n,m}?`  |   重复n到m次，但尽可能少重复    |
|  `{n,}?`  |   重复n次以上，但尽可能少重复   |

# 13.标记

标记也称为修饰符，因为它会修改正则表达式的输出。

这些标志可以以任意顺序或组合使用，并且是正则表达式的一部分。

###### 标记

| 标记 |                    描述                    |
| :--: | :----------------------------------------: |
| `i`  |  不区分大小写：将匹配设置为不区分大小写。  |
| `g`  | 全局搜索：搜索整个输入字符串中的所有匹配。 |
| `m`  |     多行匹配：会匹配输入字符串每一行。     |

## 不区分大小写

`i` 修饰符用于执行不区分大小写匹配。

* `/The/gi`：大写字母 `T`，后跟小写字母 `h`，后跟字母 `e`。 

    > 在正则匹配结束时 `i` 标记会告诉正则表达式引擎忽略这种情况。使用了 `g` 标记，因为要在整个输入字符串中搜索匹配。

## 全局搜索

`g`修饰符用于执行全局匹配（会查找所有匹配，不会在查找到第一个匹配时就停止）。

* `/.(at)/g`：除换行符之外的任意字符，后跟小写字母 a，后跟小写字母 t。 

    > 在正则表达式的末尾使用了 g 标记，它会从整个输入字符串中找到每个匹配项。

## 多行匹配

`m`修饰符被用来执行多行的匹配。

* `/at(.)?$/gm`：小写字母 `a`，后跟小写字母 `t`，匹配除了换行符以外任意字符零次或一次。

    > 因为 m 标记，现在正则表达式引擎匹配字符串中每一行的末尾。

# 16.常用正则表达式

* **正整数**：`^\d+$`

* **负整数**：`^-\d+$`

* **电话号码**：`^+?[\d\s]{3,}$`

* **电话代码**：`^+?[\d\s]+(?[\d\s]{10,}$`

* **整数**：`^-?\d+$`

* **用户名**：`^[\w\d_.]{4,16}$`

* **字母数字字符**：`^[a-zA-Z0-9]*$`

* **带空格的字母数字字符**：`^[a-zA-Z0-9 ]*$`

* **密码**：`^(?=^.{6,}$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$`

* **电子邮件**：`^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4})*$`

* **IPv4 地址**：`^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$`

* **小写字母**：`^([a-z])*$`

* **大写字母**：`^([A-Z])*$`

* **网址**：`^(((http|https|ftp):\/\/)?([[a-zA-Z0-9]\-\.])+(\.)([[a-zA-Z0-9]]){2,4}([[a-zA-Z0-9]\/+=%&_\.~?\-]*))*$`

* **VISA 信用卡号码**：`^(4[0-9]{12}(?:[0-9]{3})?)*$`

* **日期（MM/DD/YYYY）**：`^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]{2}$`

* **日期（YYYY/MM/DD）**：`^(19|20)?[0-9]{2}[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$`

* **万事达信用卡号码**：`^(5[1-5][0-9]{14})*$`